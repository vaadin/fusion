import { constants } from 'node:fs';
import { access, mkdir, readFile, rm, writeFile } from 'node:fs/promises';
import { createRequire } from 'node:module';
import { dirname, isAbsolute, join, resolve } from 'node:path';
import { pathToFileURL } from 'node:url';
import type File from '@hilla/generator-typescript-core/File.js';
import Plugin, { type PluginConstructor } from '@hilla/generator-typescript-core/Plugin.js';
import type LoggerFactory from '@hilla/generator-typescript-utils/LoggerFactory.js';
import GeneratorIOException from './GeneratorIOException.js';

const require = createRequire(import.meta.url);

type PluginConstructorModule = Readonly<{
  default: PluginConstructor;
}>;

export default class GeneratorIO {
  static readonly INDEX_FILENAME = 'generated-file-list.txt';
  declare ['constructor']: typeof GeneratorIO;
  readonly cwd: string;
  readonly #logger: LoggerFactory;
  readonly #outputDir: string;

  constructor(outputDir: string, logger: LoggerFactory) {
    this.cwd = process.cwd();
    this.#outputDir = isAbsolute(outputDir) ? outputDir : resolve(this.cwd, outputDir);
    this.#logger = logger;

    logger.global.info(`Output directory: ${this.#outputDir}`);
  }

  /**
   * Gets the list of files generated the last time. The info is found in {@link INDEX_FILENAME}.
   * @returns a list of files that have been generated by us
   */
  async getGeneratedFiles(): Promise<Set<string>> {
    try {
      const indexFileContents = await this.read(this.getGeneratedFile(this.constructor.INDEX_FILENAME));
      const fileNames = indexFileContents.split('\n').filter((n) => n.length);
      return new Set(fileNames);
    } catch (e) {
      // non-existing file is OK, all other errors must be rethrown
      if (!(e instanceof Error && 'code' in e && e.code === 'ENOENT')) {
        throw e;
      }
    }
    return new Set();
  }

  /**
   * Cleans the output directory by keeping the generated files and deleting the rest of the given files.
   *
   * @returns a set containing deleted filenames
   */
  async cleanOutputDir(generatedFiles: string[], filesToDelete: Set<string>): Promise<Set<string>> {
    this.#logger.global.debug(`Cleaning ${this.#outputDir}`);
    await mkdir(this.#outputDir, { recursive: true });

    generatedFiles.forEach((filename) => {
      this.#logger.global.debug(`File ${filename} was re-written, should not delete it`);
      filesToDelete.delete(filename);
    });

    let deletedFiles: Set<string> | undefined;

    deletedFiles = new Set(
      await Promise.all(
        [...filesToDelete].map(async (filename) => {
          const resolved = this.getGeneratedFile(filename);
          if (await this.exists(resolved)) {
            this.#logger.global.debug(`Deleting file ${filename}.`);
            await rm(resolved);
          }
          return filename;
        }),
      ),
    );

    return deletedFiles ?? new Set();
  }

  async createFileIndex(filenames: string[]): Promise<void> {
    await writeFile(this.getGeneratedFile(this.constructor.INDEX_FILENAME), filenames.join('\n'), 'utf-8');
  }

  async writeChangedFiles(files: readonly File[]) {
    await this.createFileIndex(files.map((file) => file.name));

    return Promise.all(
      files.map(async (file) => {
        const newFileContent = await file.text();
        let oldFileContent;
        try {
          oldFileContent = await this.read(this.getGeneratedFile(file.name));
        } catch (_e) {
          oldFileContent = undefined;
        }

        if (newFileContent !== oldFileContent) {
          this.#logger.global.debug(`writing file ${file.name}`);
          await this.write(file);
        } else {
          this.#logger.global.debug(`File ${file.name} stayed the same`);
        }
        return file.name;
      }),
    );
  }

  /**
   * Checks that a file exists (is visible)
   * @param path - the file path to check
   */
  // eslint-disable-next-line class-methods-use-this
  async exists(path: string): Promise<boolean> {
    try {
      await access(path, constants.F_OK);
      return true;
    } catch {
      return false;
    }
  }

  async loadPlugin(modulePath: string): Promise<PluginConstructor> {
    this.#logger.global.debug(`Loading plugin: ${modulePath}`);
    const module: PluginConstructorModule = await import(pathToFileURL(require.resolve(modulePath)).toString());
    const ctr: PluginConstructor = module.default;

    if (!Object.prototype.isPrototypeOf.call(Plugin, ctr)) {
      throw new GeneratorIOException(`Plugin '${modulePath}' is not an instance of a Plugin class`);
    }

    return ctr;
  }

  getGeneratedFile(filename: string): string {
    return resolve(this.#outputDir, filename);
  }

  async read(path: string): Promise<string> {
    this.#logger.global.debug(`Reading file: ${path}`);
    return readFile(path, 'utf8');
  }

  async write(file: File): Promise<void> {
    const filePath = join(this.#outputDir, file.name);
    this.#logger.global.debug(`Writing file ${filePath}.`);
    const dir = dirname(filePath);
    await mkdir(dir, { recursive: true });
    return writeFile(filePath, new Uint8Array(await file.arrayBuffer()));
  }
}
