import { EventEmitter } from 'node:events';
import { existsSync, rmSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { expect, use } from 'chai';
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import sinonChai from 'sinon-chai';
import vitePluginFileSystemRouter from '../../src/vite-plugin';
import { createTestingRouteFiles, createTmpDir } from '../utils';

use(chaiAsPromised);
use(sinonChai);

describe('@vaadin/hilla-file-router', () => {
  describe('vite-plugin', () => {
    let mockServer: { hot: { send: any }; watcher: EventEmitter };
    let generatedDir: URL;
    let viewsDir: URL;

    async function expectRuntimeFileGeneratedOnFileChange(changedFileName: string, expectGeneration: boolean) {
      await createTestingRouteFiles(viewsDir);
      rmSync(new URL('file-routes.json', generatedDir));
      mockServer.watcher.emit('change', fileURLToPath(new URL(changedFileName, generatedDir)));
      await new Promise((resolve) => {
        // Wait some time to ensure that the files have been written
        setTimeout(resolve, 1000);
      });
      expect(existsSync(new URL('file-routes.json', generatedDir))).to.be.equal(expectGeneration);
      expect(mockServer.hot.send).to.not.be.called;
    }

    before(async () => {
      // const rootDir = pathToFileURL('/path/to/project/');
      const rootDir = await createTmpDir();
      const outDir = new URL('dist/', rootDir);
      viewsDir = new URL('frontend/views/', rootDir);
      generatedDir = new URL('frontend/generated/', rootDir);
      const watcher = new EventEmitter();
      mockServer = {
        hot: {
          send: sinon.spy(),
        },
        watcher,
      };
      const plugin = vitePluginFileSystemRouter({ isDevMode: true, debug: true });
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error: the configResolved method could be either a function or an object.
      plugin.configResolved({
        logger: { info: sinon.spy(), warn: sinon.spy(), error: sinon.spy() },
        root: fileURLToPath(rootDir),
        build: { outDir: fileURLToPath(outDir) },
      });
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error: the configResolved method could be either a function or an object.
      plugin.configureServer(mockServer);
    });

    beforeEach(() => {
      sinon.resetHistory();
    });

    it('should send fs-route-update when file-routes.json is added', () => {
      expect(mockServer.hot.send).to.not.be.called;
      mockServer.watcher.emit('add', fileURLToPath(new URL('file-routes.json', generatedDir)));
      expect(mockServer.hot.send).to.be.calledWith({ type: 'custom', event: 'fs-route-update' });
    });

    it('should send fs-route-update when file-routes.json changes', () => {
      expect(mockServer.hot.send).to.not.be.called;
      mockServer.watcher.emit('change', fileURLToPath(new URL('file-routes.json', generatedDir)));
      expect(mockServer.hot.send).to.be.calledWith({ type: 'custom', event: 'fs-route-update' });
    });

    it('should not send full-reload when other files change', () => {
      expect(mockServer.hot.send).to.not.be.called;
      mockServer.watcher.emit('change', fileURLToPath(new URL('file.tsx', viewsDir)));
      expect(mockServer.hot.send).to.not.be.called;
    });

    it('should regenerate files when layouts.json is updated', async () => {
      await expectRuntimeFileGeneratedOnFileChange('layouts.json', true);
    });

    it('should not regenerate files when another file is updated', async () => {
      await expectRuntimeFileGeneratedOnFileChange('something.json', false);
    });
  });
});
